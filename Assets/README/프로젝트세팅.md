### Collision 세팅

> 발생한 문제 : 키네마틱 설정을 키면 OnCollider OnTrigger이 인식이 안되는 오류가 있다.

**① Projectile**
<div align=center>
    <img src="2023-05-17-21-04-32.png" width=500px><br>
    Projectile의 설정은 다음과 같다.
</div>

**② 키네마틱 세팅을 키면 트리거 엔터가 활성화 되지 을때**

<div align=center>
    <img src="2023-05-17-17-50-35.png" width=500px><br>
    Edit -> Project Setting -> Physics
</div>

**③ 대충 작동 안했던 코드**

*
    ```cs
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;
    using UnityEngine.Events;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Linq;

    public class Projectile : MonoBehaviour {
        public GameObject HitEffect;
        public Collider HitCollider;
        public ParticleSystem Particle;
        public float HitBoxLifeTime;
        public Dictionary<Affector_PlayerState ,IModifier> Modifiers;

        public LayerMask ownerMask;
        //private void OnCollisionEnter(Collision other) "Collision"
        //private void OnTriggerEnter(Collider other)    "Collider"
        // 이 코드가 붙어있는 콜라이더 컴포넌트가 IsTrigger이 되야 작동 하는것
        private void OnTriggerEnter(Collider other) {
            if(ownerMask.value == other.gameObject.layer) {return;}
            Debug.Log($"{other.gameObject.name}, Collider Trigger");
            other.gameObject.TryGetComponent<IDamagable>(out IDamagable damagebleEntity);
            other.gameObject.TryGetComponent<IAffectable>(out IAffectable affectableEntity);
            damagebleEntity.GetDamaged(5);
            affectableEntity.AsyncAffectHandler(this.affectorType,new PoisonState(damagebleEntity).AsyncAffectorCoroutine);
        }
    }
    ```

**④ 참고**

* https://answers.unity.com/questions/209656/having-a-kinematic-rigidbody-detect-collision-with.html

* https://linecode.tistory.com/5

---

### 몬스터의 구조

<div align=center>
    <img src="2023-05-18-09-15-53.png" width=250px><br>
    Edit -> Project Setting -> Physics
</div>

```txt
몬스터 구조
    몬스터
    ├── 월드스페이스
    │   ├── 모델 : 3D 리소스들을 저장한다
    │   ├── VFXBucket : 파티클, 피격 이펙트의 생성
    │   ├── ProjectileBucket : 투사체 생성지점
    │   └── Bilboard UI : 캐릭터에 표함된 World캔버스
    └── 스크린 스페이스
```

---

### Destroying assets is not permitted to avoid data loss.

> 즉, 니가 삭제하려는 오브젝트가 프리펩이냐? 해서 데이터 안전을 위해 뜨는 오류
> 복사 해놓고 삭제하란다.

**① 프로젝타일 코드 Before & After**

* before
    ```cs
    /*Projectile*/

    public void InstanciateProjectile(GameObject _owner, Quaternion _angle){
        spawnOwner = _owner;
        Instantiate(gameObject, transform.position, _angle);

    }
    public void InstanciateProjectile(GameObject _owner){
        spawnOwner = _owner;
        Instantiate(gameObject, transform);
    }
    ```
* after
    ```cs
    /*Projectile*/
    
    //여기를 통해서 이 스크립트를 실행한 놈을 호출 할 수 있다.
    public GameObject InstanciateProjectile(GameObject _owner, Transform parent){
        spawnOwner = _owner;
        return Instantiate(gameObject, parent.position, parent.rotation);
    }
    ```

**② 프로젝타일 버킷 코드 Before & After**

* before
    ```cs
    /*ProjectileBucket.cs*/

    public void ProjectileInstantiator(Projectile projectile){
        projectile.InstanciateProjectile(gameObject);
        Destroy(projectile, 0.6f);
    }
    ```
* after
    ```cs
    /*ProjectileBucket.cs*/
    
    public void ProjectileInstantiator(Projectile projectile){
        Destroy(projectile.InstanciateProjectile(gameObject, transform), 0.6f);
    }
    ```



https://forum.unity.com/threads/destroying-assets-is-not-permitted-to-avoid-data-loss.1270514/

---

### ScriptableObject Data 사용

> 다음은 스크립터블 오브젝트를 실험하기 위해서 임시로 넣었던 코드였고, 현재는 없다.
> 다음이 설명하는 바는 플라이 웨이트가 되는 객체를 변경 시키지 마라
> 이 데이터를 참조하는 모든 객체에 영향으 끼치기 때문다.

```
/*Sandbag.cs*/
/*
[ContextMenu("GetDamaged", false, int.MaxValue)]
public void GetDamaged(){
    //this.sandbagData.CurHP -= 334;
    CurHP -= 334;
    //this.hpChangedEvent.Invoke();
    //if (this.sandbagData.CurHP <= 0) {Die();}
    if (CurHP <= 0) {Die();}
}
// 공유 되는 데이터 이므로 인스턴스마다 차이나는 값을 지정해서는 안된다.
//private void Update() {
//    if (this.sandbagData.CurHP <= 0){Die();}
//}
*/
```

---

### 메쉬의 위치
블렌더

![](2023-05-18-11-06-44.png)

유니티 
![](2023-05-18-11-07-42.png)

---

### DynamicsArchtecture

플레이어, 몬스터와 같은 Entity의 동작은 인터페이스를 통해 소통하도록 한다.

디버프의 사용법
```cs
private void OnTriggerEnter(Collider other) {
    //인터페이스를 구현한 객체를 받는다.
    IDamagable damagebleEntity = other.gameObject.GetComponent<IDamagable>();
    IAffectable affectableEntity = other.gameObject.
    GetComponent<IAffectable>();

    //전달 하기
    damagebleEntity.GetDamaged(_amount: 5, HitEffect);
    //디버프는 new를 사용하여 생성하고,
    //AsyncAffectorCoroutine에 그 효과(매소드)가 담겨 있다.
    //IAffectable는 AsyncAffectorCoroutine을 처리하는 인터페이스다. 
    affectableEntity.AsyncAffectHandler(this.affectorType,new PoisonState(other.gameObject).AsyncAffectorCoroutine);
}
```

```cs
//생성자에 이 함수가 실행될 대상을 넣어 준다
PoisonState poison = new PoisonState(other.gameObject);
affectableEntity.AsyncAffectHandler(this.affectorType,poison.AsyncAffectorCoroutine);
```

---

### Pipeline
앞으로 파이프라인이란,
몬스터와 플레이어, 플레이ㄴ어와 무기, 플레이어와 부품 등등
각기 다른것들과 데이터 통신을 위한 클래스가 될것이다.

모든 능력치 변화는 무조건 파이프라인과의 연산을 통해서 이뤄진다.

### 커스텀 클래스 시리얼라이즈화
A 클래스를 포함하는곳에 A를 인스펙터에 보여지게 하고 싶다면..
```cs
[System.Serializable]
public class A {
    [field : SerializeField] var one;
    [field : SerializeField] var two;
    [field : SerializeField] var three;
    [field : SerializeField] var four;
    ...
}
```

```cs
[field : SerializeField]
A a;
```

사용한 예시
![](2023-05-20-16-32-33.png)

```cs
[System.Serializable]
public class AddingData {
    
    [field : SerializeField] public int      MaxHP       {get; set;}
    [field : SerializeField] public int      CurHP       {get; set;}
    [field : SerializeField] public float    MoveSpeed   {get; set;}
    [field : SerializeField] public float    Defence     {get; set;}
    [field : SerializeField] public float    Tenacity    {get; set;}
    [field : SerializeField] public int      MaxStamina  {get; set;}
    [field : SerializeField] public int      CurStamina  {get; set;}
    [field : SerializeField] public float    Power       {get; set;}
    [field : SerializeField] public int      Luck        {get; set;}
    [field : SerializeField] public int      Gear        {get; set;}
    [field : SerializeField] public int      Frag        {get; set;}
    [field : SerializeField] public float    DamageRatio {get; set;}
    [field : SerializeField] public float    WeaponDelay {get; set;}
    [field : SerializeField] public float    Range       {get; set;}
    [field : SerializeField] public int      Ammo        {get; set;}
    public SkillRankInfo[] SkillRankInfos;
```

```cs
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Events;

[CreateAssetMenu(fileName = "EquipmentData", menuName = "ScriptableObject/Equipment", order = int.MaxValue)]
public class ScriptableObjEquipmentData : ScriptableObject {
    public string equipmentName;
    public string description;
    public Sprite sprite;
    [field : SerializeField]
    AddingData addingData;
}
```

### Git Stash 했던 Enemy

![](2023-05-23-09-43-44.png)

![](2023-05-23-09-43-34.png)

[GitStash 에 대한 정보](https://backlog.com/git-tutorial/kr/reference/stash.html)

### DataClone

[DeepCopy](https://zzang9ha.tistory.com/372)

### 엔티티 클래스와 이걸 상속 받는 애들